local ast = require "pallene.ast"
local pretty = require "pallene.pretty"
local typedecl = require "pallene.typedecl"
local types = require "pallene.types"
local upvalues = require "pallene.upvalues"
local util = require "pallene.util"

local coder = {}

local generate_program
local generate_stat
local generate_var
local generate_exp

function coder.generate(prog, modname)
    local code = generate_program(prog, modname)
    return code, {}
end


-- While generating code we set some extra fields in the AST.
-- In theory we could have stored this info another way, since these fields
-- don't need to be passed to a following pass.
--
-- _cvar:
--     In Decl nodes. (see @decl)
--
-- _lua_entry_point:
-- _pallene_entry_point:
--     In Toplevel.Func nodes.
--     Names of the C functions that we generate for each pallene function
--
-- _rec:
--     In Toplevel.Record nodes. (see @records)

local whole_file_template = [[
/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

${STRUCTS}

${DECLARE_FUNCTIONS}

${DEFINE_FUNCTIONS}

${LUAOPEN_FUNCTION}
]]

--
--
--

local function declare_type(typename, cons)
    typedecl.declare(coder, "coder", typename, cons)
end

--
-- C syntax
--

-- Technically, we only need to escape the quote and backslash
-- But quoting some extra things helps readability...
local some_c_escape_sequences = {
    ["\\"] = "\\\\",
    ["\""] = "\\\"",
    ["\a"] = "\\a",
    ["\b"] = "\\b",
    ["\f"] = "\\f",
    ["\n"] = "\\n",
    ["\r"] = "\\r",
    ["\t"] = "\\t",
    ["\v"] = "\\v",
}

local function c_string(s)
    return '"' .. (s:gsub('.', some_c_escape_sequences)) .. '"'
end

local function c_integer(n)
    return string.format("%i", n)
end

local function c_boolean(b)
    if b then
        return c_integer(1)
    else
        return c_integer(0)
    end
end

local function c_float(n)
    -- Use hexadecimal float literals (%a) to avoid losing any precision.
    -- This feature is part of the C99 and C++17 standards. An alternative
    -- C89-compatiple solution might be to refactor the Pallene compiler to
    -- represent float literals as strings instead of as numbers.
    return string.format("%a /*%f*/", n, n)
end

-- @param type Type of the pallene value
-- @returns type of the corresponding C variable
--
-- We currently represent C types as strings. This suffices for primitive types
-- and pointers to primitive types but we might need to switch to a full ADT if
-- we decide to also support array and function pointer types.
local function ctype(typ)
    local tag = typ._tag
    if     tag == types.T.Nil      then return "int"
    elseif tag == types.T.Boolean  then return "int"
    elseif tag == types.T.Integer  then return "lua_Integer"
    elseif tag == types.T.Float    then return "lua_Number"
    elseif tag == types.T.String   then return "TString *"
    elseif tag == types.T.Function then return "TValue"
    elseif tag == types.T.Array    then return "Table *"
    elseif tag == types.T.Record   then return "Udata *"
    else error("impossible")
    end
end

--
-- @decl
--

local function new_cvar(name, ctyp, comment)
    return { name = name, ctyp = ctyp, comment = comment }
end

local function new_tvar(cvar, typ)
    return { cvar = cvar, typ = typ }
end

-- @returns A syntactically valid variable declaration
local function c_declaration(cvar)
    local comment
    if cvar.comment then
        comment = string.format(" /* %s */", cvar.comment)
    else
        comment = ""
    end
    return string.format("%s %s%s", cvar.ctyp, cvar.name, comment)
end

local function init_cvar(cvar, exp)
    local out = util.render([[
        ${DECL} = ${EXP};
    ]], {
        DECL = c_declaration(cvar),
        EXP = exp,
    })
    return out
end

-- Indicates which GC variables should be saved in the Lua stack and which slot
-- they need to be saved in.
local Context = {}
Context.__index = Context

function Context.new(literals)
    local o = {
        tmp_index = 1,       -- next free tmp variable name

        n_stack_slots = 0,   -- current number of used stack slots
        max_stack_slots = 0, -- maximum number of needed stack slots

        live_vars = {},      -- (superset of) current live gc variables
        scopes = {},         -- first index of each scope

        n_saved_vars = 0,    -- how many vars are currently saved in stack
        saveds = {},         -- first index of each group of saved variables

        literals = literals, -- map a literal to upvalue index (see @literals)
        upv = false,         -- upvalues table and array (see @upvalues)
    }
    return setmetatable(o, Context)
end

function Context:reserve_slots(n)
    assert(n >= 0)
    self.n_stack_slots = self.n_stack_slots + n
    self.max_stack_slots = math.max(self.max_stack_slots, self.n_stack_slots)
end

function Context:free_slots(n)
    assert(n >= 0)
    self.n_stack_slots = self.n_stack_slots - n
    assert(self.n_stack_slots >= self.n_saved_vars)
end

function Context:begin_scope()
    table.insert(self.scopes, #self.live_vars + 1)
end

function Context:end_scope()
    assert(#self.scopes > 0)
    local scope_start = self.scopes[#self.scopes]
    assert(scope_start > self.n_saved_vars)
    for _ = #self.live_vars, scope_start, -1 do
        table.remove(self.live_vars)
    end
    table.remove(self.scopes)
end

function Context:begin_save()
    local first = self.n_saved_vars + 1
    local last  = #self.live_vars
    local n = last - first + 1
    self:reserve_slots(n)
    self.n_saved_vars = last
    table.insert(self.saveds, first)
    return first, last, n
end

function Context:end_save()
    assert(#self.saveds > 0)
    local first = self.saveds[#self.saveds]
    local last  = self.n_saved_vars
    local n = last - first + 1
    table.remove(self.saveds)
    self.n_saved_vars = first - 1
    self:free_slots(n)
    return first, last, n
end

function Context:new_name()
    local index = self.tmp_index
    self.tmp_index = self.tmp_index + 1
    return string.format("x%d", index)
end

function Context:new_cvar(ctyp, comment)
    local name = self:new_name()
    return new_cvar(name, ctyp, comment)
end

function Context:new_tvar(typ, comment)
    local cvar = self:new_cvar(ctype(typ), comment)
    if types.is_gc(typ) then
        table.insert(self.live_vars, new_tvar(cvar, typ))
    end
    return cvar
end

--
--
--

local function function_name(funcname, kind)
    return string.format("function_%s_%s", funcname, kind)
end

local function get_slot(typ, src_slot_address)
    local tmpl
    local tag = typ._tag
    if     tag == types.T.Nil      then tmpl = "0"
    elseif tag == types.T.Boolean  then tmpl = "bvalue(${SRC})"
    elseif tag == types.T.Integer  then tmpl = "ivalue(${SRC})"
    elseif tag == types.T.Float    then tmpl = "fltvalue(${SRC})"
    elseif tag == types.T.String   then tmpl = "tsvalue(${SRC})"
    elseif tag == types.T.Function then tmpl = "*(${SRC})"
    elseif tag == types.T.Array    then tmpl = "hvalue(${SRC})"
    elseif tag == types.T.Record   then tmpl = "uvalue(${SRC})"
    else error("impossible")
    end
    local out = util.render(tmpl, {SRC = src_slot_address})
    return out
end


-- Don't call this function directly, call set_stack_slot or set_heap_slot
-- instead
local function set_slot_(typ, dst_slot_address, value)
    local tmpl
    local tag = typ._tag
    if     tag == types.T.Nil      then tmpl = "(void) ${SRC}; setnilvalue(${DST});"
    elseif tag == types.T.Boolean  then tmpl = "setbvalue(${DST}, ${SRC});"
    elseif tag == types.T.Integer  then tmpl = "setivalue(${DST}, ${SRC});"
    elseif tag == types.T.Float    then tmpl = "setfltvalue(${DST}, ${SRC});"
    elseif tag == types.T.String   then tmpl = "setsvalue(L, ${DST}, ${SRC});"
    elseif tag == types.T.Function then tmpl = "setobj(L, ${DST}, &${SRC});"
    elseif tag == types.T.Array    then tmpl = "sethvalue(L, ${DST}, ${SRC});"
    elseif tag == types.T.Record   then tmpl = "setuvalue(L, ${DST}, ${SRC});"
    else error("impossible")
    end
    local out = util.render(tmpl, { DST = dst_slot_address, SRC = value })
    return out
end

-- Specialized version of luaH_barrierback. To be called when setting v as an
-- element of p. This is intended to preserve the invariant that black objects
-- cannot point to white objects.
--
-- Instead of checking iscollectable(v) at runtime, we determine this at compile
-- time. And instead of v being a TValue*, it is an internal pointer (as
-- described by ctype()), just like p.
--
-- @param typ: Type of child object
-- @param p: Internal pointer to parent object
-- @param v: Internal pointer to child object
-- @returns C statements
local function barrierback(typ, p, v)
    if not types.is_gc(typ) then
        return ""
    elseif typ._tag == types.T.Function then
        local out = util.render([[
            if (iscollectable(&${V}) && isblack(obj2gco(${P})) && iswhite(gcvalue(&${V}))) {
                luaC_barrierback_(L, obj2gco(${P}));
            }
        ]], {
            P = p,
            V = v,
        })
        return out
    else
        local out = util.render([[
            if (isblack(obj2gco(${P})) && iswhite(obj2gco(${V}))) {
                luaC_barrierback_(L, obj2gco(${P}));
            }
        ]], {
            P = p,
            V = v,
        })
        return out
    end
end

local function set_stack_slot(typ, dst, src)
    return set_slot_(typ, dst, src)
end

local function set_heap_slot(typ, dst, src, parent)
    local out = util.render([[
        ${SET_SLOT}
        ${BARRIER}
    ]], {
        SET_SLOT = set_slot_(typ, dst, src),
        BARRIER = barrierback(typ, parent, src),
    })
    return out
end

local function push_to_stack(ctx, typ, src)
    ctx:reserve_slots(1)
    local out = util.render([[
        ${SET_SLOT}
        api_incr_top(L);
    ]],{
        SET_SLOT = set_stack_slot(typ, "s2v(L->top)", src),
    })
    return out
end

--
-- GC
--

-- Reserves stack space. This should go at the start of the generated function
-- but this should be the last piece of code to be generated, so it can know how
-- big the stack needs to be.
local function gc_reserve_stack(ctx)
    local n = ctx.max_stack_slots
    if n > 0 then
        local out = util.render([[
            lua_checkstack(L, ${N});
        ]], {
            N = c_integer(n),
        })
        return out
    else
        return ""
    end
end

-- Push potentially live variables to the Lua stack, so the Lua GC can see they
-- are not garbage.
local function gc_save_vars(ctx)
    local first, last, n = ctx:begin_save()

    -- Avoid warnings
    if n == 0 then
        return ""
    end

    local parts = {}

    local top = ctx:new_cvar("StackValue*")
    table.insert(parts, util.render([[
        ${TOP_DECL} = L->top;
    ]], {
        TOP_DECL = c_declaration(top)
    }))

    for i = first, last do
        local tvar = ctx.live_vars[i]
        local slot = util.render("s2v($TOP)", { TOP = top.name })
        table.insert(parts, util.render([[
            ${SET_SLOT} ${TOP}++;
        ]], {
            SET_SLOT = set_stack_slot(tvar.typ, slot, tvar.cvar.name),
            TOP = top.name,
        }))
    end

    table.insert(parts, util.render([[
        L->top = ${TOP};
    ]], {
        TOP = top.name
    }))

    return table.concat(parts, "\n")
end

-- Release variables saved by gc_save_vars
local function gc_release_vars(ctx)
    local _, _, n = ctx:end_save()

     -- Avoid warnings
    if n == 0 then
        return ""
    end

    local out = util.render([[
        L->top -= ${NSLOTS};
    ]], {
        NSLOTS = c_integer(n)
    })
    return out
end

-- Insert a call to luaC_condgc in the program. This invokes the garbage
-- collector and calls the stack-saving code only if needed.
local function gc_cond_gc(ctx)
    local save_vars = gc_save_vars(ctx)
    local release_vars = gc_release_vars(ctx)
    local out = util.render([[
        luaC_condGC(L, {
            ${SAVE_VARS}
        }, {
            ${RELEASE_VARS}
        });
    ]],{
        SAVE_VARS = save_vars,
        RELEASE_VARS = release_vars,
    })
    return out
end

--
-- @upvalues
--

local function upvalues_create_table(n, ctx)
    if n == 0 then return "" end

    -- This is a bit of a hack... we need to declare this variable as a tvar
    -- to avoid letting it be garbage collected, but in order to do that we
    -- need to pretend that it has a Pallene type...
    --
    -- We might be able to do this away after the IR refactor, which will
    -- change how the garbage collection and variable-saving works.
    local typ = types.T.Record(false)

    ctx.upv = {}
    ctx.upv.table = ctx:new_tvar(typ) -- tvar: Don't GC this!
    ctx.upv.array = ctx:new_cvar("UValue *")

    local out = util.render([[
        ${UDATA_DECL} = luaS_newudata(L, 0, ${N});
        ${ARRAY_DECL} = ${UDATA}->uv;
    ]], {
        N = c_integer(n),
        UDATA = ctx.upv.table.name,
        UDATA_DECL = c_declaration(ctx.upv.table),
        ARRAY = ctx.upv.array.name,
        ARRAY_DECL = c_declaration(ctx.upv.array),
    })
    return out
end

local function upvalues_init_local_cvars(ctx)
    local closure = ctx:new_cvar("CClosure *")

    ctx.upv = {}
    ctx.upv.table = ctx:new_cvar("Udata *", "upvalue table")
    ctx.upv.array = ctx:new_cvar("UValue *", "upvalue array")

    local out = util.render([[
        ${CLOSURE_DECL} = clCvalue(s2v(L->ci->func));
        ${UDATA_DECL} = uvalue(&${CLOSURE}->upvalue[0]);
        ${ARRAY_DECL} = ${UDATA}->uv;
        (void)${ARRAY};
    ]], {
        CLOSURE = closure.name,
        CLOSURE_DECL = c_declaration(closure),
        UDATA = ctx.upv.table.name,
        UDATA_DECL = c_declaration(ctx.upv.table),
        ARRAY = ctx.upv.array.name,
        ARRAY_DECL = c_declaration(ctx.upv.array),
    })
    return out
end

local function upvalues_slot(i, ctx)
    local out = util.render([[ &${ARR}[${I}].uv ]], {
        ARR = ctx.upv.array.name,
        I = c_integer(i - 1),
    })
    return out
end

local function upvalues_table(ctx)
    return ctx.upv.table.name
end

--
-- @literals
--

local function literal_get(lit, ctx)
    -- TODO: this requires the upvalues table to be initalized, we should make
    -- more resilient
    assert(upvalues_table(ctx))

    local typ = types.T.String()
    local slot = ctx:new_cvar("TValue *")
    local out = ctx:new_tvar(typ)
    local i = assert(ctx.literals[lit], "lit not found: " .. lit)
    local cstats = util.render([[
        ${SLOT_DECL} = ${UPV_SLOT};
        ${OUT_DECL} = ${GET_SLOT};
    ]], {
        SLOT_DECL = c_declaration(slot),
        UPV_SLOT = upvalues_slot(i, ctx),
        OUT_DECL = c_declaration(out),
        GET_SLOT = get_slot(typ, slot.name),
    })
    return cstats, out.name
end

--
-- @table
--

local function table_newkey(tabl, lit, ctx)
    local key_cstats, key = literal_get(lit, ctx)
    local key_type = types.T.String()
    local key_slot = ctx:new_cvar("TValue")
    local key_slot_addr = "&" .. key_slot.name
    local field = ctx:new_cvar("TValue *")
    local cstats = util.render([[
        ${KEY_CSTATS}
        ${KEY_SLOT_DECL};
        ${SET_KEY_SLOT}
        ${SLOT_DECL} = luaH_newkey(L, ${TABL}, ${KEY_SLOT_ADDR});
    ]], {
        KEY_CSTATS = key_cstats,
        KEY_SLOT_DECL = c_declaration(key_slot),
        KEY_SLOT_ADDR = key_slot_addr,
        SET_KEY_SLOT = set_stack_slot(key_type, key_slot_addr, key),
        SLOT_DECL = c_declaration(field),
        TABL = tabl,
    })
    return cstats, field.name
end

local function table_set_new_field(tabl, lit, typ, cvalue, ctx)
    local field_cstats, field = table_newkey(tabl, lit, ctx)
    local out = util.render([[
        ${FIELD_CSTATS}
        ${SET_SLOT}
    ]], {
        FIELD_CSTATS = field_cstats,
        SET_SLOT = set_heap_slot(typ, field, cvalue, tabl),
    })
    return out
end

-- TODO: this should be types.T.LuaRecord()
local metatable_type = types.T.Array(types.T.Integer())

--
-- @tags
--

local function check_tag(typ, slot, ctx)
    local tmpl
    local tag = typ._tag
    if     tag == types.T.Nil      then tmpl = "ttisnil(${SLOT})"
    elseif tag == types.T.Boolean  then tmpl = "ttisboolean(${SLOT})"
    elseif tag == types.T.Integer  then tmpl = "ttisinteger(${SLOT})"
    elseif tag == types.T.Float    then tmpl = "ttisfloat(${SLOT})"
    elseif tag == types.T.String   then tmpl = "ttisstring(${SLOT})"
    elseif tag == types.T.Function then tmpl = "ttisfunction(${SLOT})"
    elseif tag == types.T.Array    then tmpl = "ttistable(${SLOT})"
    elseif tag == types.T.Record   then
        local mt_index = typ.type_decl._upvalue_index
        local mt_slot = upvalues_slot(mt_index, ctx)
        return util.render(
            [[(ttisfulluserdata(${SLOT}) && ${UDATA}->metatable == ${MT})]],
        {
            SLOT = slot,
            UDATA = get_slot(typ, slot),
            MT = get_slot(metatable_type, mt_slot),
        })
    else error("impossible")
    end
    return util.render(tmpl, {SLOT = slot})
end

local function pallene_type_tag(typ)
    local tag = typ._tag
    if     tag == types.T.Nil      then return "LUA_TNIL"
    elseif tag == types.T.Boolean  then return "LUA_TBOOLEAN"
    elseif tag == types.T.Integer  then return "LUA_TNUMINT"
    elseif tag == types.T.Float    then return "LUA_TNUMFLT"
    elseif tag == types.T.String   then return "LUA_TSTRING"
    elseif tag == types.T.Function then return "LUA_TFUNCTION"
    elseif tag == types.T.Array    then return "LUA_TTABLE"
    elseif tag == types.T.Record   then return "LUA_TUSERDATA"
    else error("impossible")
    end
end

--
-- @records
--
-- Records are implemented with full userdata (Udata *), where the gc fields are
-- stored in the UValue array and primitive fields in the mem part.
-- With this layout, pallene is able to compute each field offset during compile
-- time.
-- In order to read and write record fields in Lua, we implement __index and
-- __newindex methametods for each record type.
--

local function compute_layout(tl_node)
    local gc_pos = {}
    local gc_index = 1
    local prim_pos = {}
    local prim_index = 1
    for _, field in ipairs(tl_node.field_decls) do
        local typ = tl_node._field_types[field.name]
        if types.is_gc(typ) then
            gc_pos[field.name] = gc_index
            gc_index = gc_index + 1
        else
            prim_pos[field.name] = prim_index
            prim_index = prim_index + 1
        end
    end
    return {
        gc_pos = gc_pos,
        gc_size = gc_index - 1,
        prim_pos = prim_pos,
        prim_size = prim_index - 1,
    }
end

local RecordCoder = {}
RecordCoder.__index = RecordCoder

function RecordCoder.new(tl_node)
    local o = {
        tl_node = tl_node,
        layout = compute_layout(tl_node),
    }
    return setmetatable(o, RecordCoder)
end

function RecordCoder:struct()
    return string.format("struct record_%s", self.tl_node.name)
end

function RecordCoder:index()
    return string.format("record_index_%s", self.tl_node.name)
end

function RecordCoder:newindex()
    return string.format("record_newindex_%s", self.tl_node.name)
end

function RecordCoder:field(name)
    return string.format("f%d", self.layout.prim_pos[name])
end

function RecordCoder:field_type(name)
    return self.tl_node._field_types[name]
end

function RecordCoder:field_slot(udata, name)
    local typ = self:field_type(name)
    local slot
    if types.is_gc(typ) then
        slot = self:gc_slot(udata, name)
    else
        slot = self:primitive_slot(udata, name)
    end
    return slot, typ
end

function RecordCoder:gc_size()
    return self.layout.gc_size
end

function RecordCoder:mem_size()
    if self.layout.prim_size == 0 then
        return 0
    else
        return string.format("sizeof(%s)", self:struct())
    end
end

function RecordCoder:declare_struct()
    -- Empty struct are not allowed in standard C (they are a GCC extension)
    if self.layout.prim_size == 0 then return "" end

    local fields = {}
    for _, field in ipairs(self.tl_node.field_decls) do
        local typ = self:field_type(field.name)
        if not types.is_gc(typ) then
            local name = self:field(field.name)
            local cvar = new_cvar(name, ctype(typ), field.name)
            local decl = c_declaration(cvar) .. ";"
            table.insert(fields, decl)
        end
    end

    local out = util.render([[
        $NAME {
            $FIELDS
        };
    ]], {
        NAME = self:struct(),
        FIELDS = table.concat(fields, "\n"),
    })
    return out
end

function RecordCoder:gc_slot(udata, field_name)
    local out = util.render([[&${UDATA}->uv[${I}].uv]], {
        UDATA = udata,
        I = self.layout.gc_pos[field_name] - 1,
    })
    return out
end

function RecordCoder:primitive_slot(udata, field_name)
    local out = util.render(
        [[((${STRUCT_NAME} *)getudatamem(${UDATA}))->${FIELD_NAME}]],
    {
        STRUCT_NAME = self:struct(),
        UDATA = udata,
        FIELD_NAME = self:field(field_name),
    })
    return out
end

function RecordCoder:set_field(udata, field_name, cvalue)
    local typ = self.tl_node._field_types[field_name]
    if types.is_gc(typ) then
        local slot = self:gc_slot(udata, field_name)
        return set_heap_slot(typ, slot, cvalue, udata)
    else
        local out = util.render([[
            ${SLOT} = ${CVALUE};
        ]], {
            SLOT = self:primitive_slot(udata, field_name),
            CVALUE = cvalue,
        })
        return out
    end
end

function RecordCoder:dyn_dispatch_bin(i, j, args)
    local n = j - i + 1
    if n < 1 then
        return string.format("goto %s;", args.errlabel)
    end
    local m = i + n // 2
    local field_name = args.fields[m].name
    local cmp = args.ctx:new_cvar("int")
    local out = util.render([[
        ${CMP_DECL} = strcmp(${KEY}, ${FIELD});
        if (${CMP} == 0) {
            ${ACTION}
        }
        else if (${CMP} < 0) {
            ${LOWER}
        }
        else {
            ${GREATER}
        }
    ]], {
        CMP = cmp.name,
        CMP_DECL = c_declaration(cmp),
        KEY = args.key,
        FIELD = c_string(field_name),
        ACTION = args.action(field_name),
        LOWER = self:dyn_dispatch_bin(i, m - 1, args),
        GREATER = self:dyn_dispatch_bin(m + 1, j, args),
    })
    return out
end

-- Call action (field_name -> c_decl) for each field
function RecordCoder:dyn_dispatch(key, action, errlabel, ctx)
    local sorted_fields = {}
    for _, field in ipairs(self.tl_node.field_decls) do
        table.insert(sorted_fields, field)
    end
    table.sort(sorted_fields, function(a, b) return a.name < b.name end)
    return self:dyn_dispatch_bin(1, #sorted_fields, {
        fields = sorted_fields,
        key = key,
        action = action,
        errlabel = errlabel,
        ctx = ctx,
    })
end

function RecordCoder:declare_index()
    local ctx = Context.new()

    local cstats = {}

    local rec_typ = types.T.Record(self.tl_node)
    local udata = ctx:new_tvar(rec_typ)
    local udata_init = get_slot(rec_typ, "s2v(L->ci->func + 1)")
    table.insert(cstats, init_cvar(udata, udata_init))
    table.insert(cstats, "(void)" .. udata.name .. ";")

    local key = ctx:new_cvar("const char *")
    table.insert(cstats, init_cvar(key, "svalue(s2v(L->ci->func + 2))"))

    local action = function(field_name)
        local src_slot, typ = self:field_slot(udata.name, field_name)
        local dst_slot = "s2v(L->ci->func + 2)"
        local value = ctx:new_tvar(typ)
        local init = types.is_gc(typ) and get_slot(typ, src_slot) or src_slot
        local stats = {}
        table.insert(stats, init_cvar(value, init))
        table.insert(stats, set_stack_slot(typ, dst_slot, value.name))
        return table.concat(stats, "\n")
    end
    table.insert(cstats, self:dyn_dispatch(key.name, action, "err", ctx))

    local out = util.render([[
        static int ${NAME}(lua_State *L)
        {
            ${CSTATS}
            return 1;

          err:
            return pallene_runtime_record_index_error(L, ${KEY});
        }
    ]], {
        CSTATS = table.concat(cstats, "\n"),
        NAME = self:index(),
        KEY = key.name,
    })
    return out
end

function RecordCoder:declare_newindex()
    local ctx = Context.new()

    local cstats = {}

    table.insert(cstats, upvalues_init_local_cvars(ctx))

    local rec_typ = types.T.Record(self.tl_node)
    local udata = ctx:new_tvar(rec_typ)
    local udata_init = get_slot(rec_typ, "s2v(L->ci->func + 1)")
    table.insert(cstats, init_cvar(udata, udata_init))
    table.insert(cstats, "(void)" .. udata.name .. ";")

    local key = ctx:new_cvar("const char *")
    table.insert(cstats, init_cvar(key, "svalue(s2v(L->ci->func + 2))"))

    local src_slot = ctx:new_cvar("TValue *")
    table.insert(cstats, init_cvar(src_slot, "s2v(L->ci->func + 3)"))
    table.insert(cstats, "(void)" .. src_slot.name .. ";")

    local action = function(field_name)
        local typ = self:field_type(field_name)
        local value = ctx:new_tvar(typ)
        local stats = {}
        table.insert(stats, util.render([[
            if (PALLENE_UNLIKELY(!${CHECK_TAG})) {
                pallene_runtime_record_type_error(L, ${KEY}, ${EXPECTED_TAG}, rawtt(${SRC_SLOT}));
            }
        ]], {
            CHECK_TAG = check_tag(typ, src_slot.name, ctx),
            KEY = key.name,
            EXPECTED_TAG = pallene_type_tag(typ),
            SRC_SLOT = src_slot.name,
        }))
        table.insert(stats, init_cvar(value, get_slot(typ, src_slot.name)))
        table.insert(stats, self:set_field(udata.name, field_name, value.name))
        return table.concat(stats, "\n")
    end
    table.insert(cstats, self:dyn_dispatch(key.name, action, "err", ctx))

    local out = util.render([[
        static int ${NAME}(lua_State *L)
        {
            ${CSTATS}
            return 0;

          err:
            return pallene_runtime_record_index_error(L, ${KEY});
        }
    ]], {
        CSTATS = table.concat(cstats, "\n"),
        NAME = self:newindex(),
        KEY = key.name,
    })
    return out
end

function RecordCoder:make_declarations()
    local decls = {
        self:declare_struct(),
        self:declare_index(),
        self:declare_newindex(),
    }
    return table.concat(decls, "\n")
end

function RecordCoder:create_metatable(ctx)
    local cstats = {}

    local mt = ctx:new_tvar(metatable_type)
    table.insert(cstats, util.render([[
        ${MT_DECL} = luaH_new(L);
    ]], {
        MT_DECL = c_declaration(mt),
    }))

    local function set_function(key, f)
        local typ = types.T.Function({}, {})
        local fslot = ctx:new_cvar(ctype(typ))
        local out = util.render([[
            ${FSLOT_DECL};
            setfvalue(&${FSLOT}, ${F});
            ${SET_FIELD}
        ]], {
            F = f,
            FSLOT = fslot.name,
            FSLOT_DECL = c_declaration(fslot),
            SET_FIELD = table_set_new_field(mt.name, key, typ, fslot.name, ctx),
        })
        return out
    end

    table.insert(cstats, set_function("__index", self:index()))
    table.insert(cstats, set_function("__newindex", self:newindex()))

    table.insert(cstats, table_set_new_field(mt.name, "__metatable",
            types.T.Boolean(), c_boolean(false), ctx))

    return table.concat(cstats, "\n"), mt.name
end

function RecordCoder:create_instance(typ, ctx)
    local udata = ctx:new_tvar(typ)
    local mt_slot = upvalues_slot(self.tl_node._upvalue_index, ctx)
    local cstats = util.render([[
        ${UDATA_DECL} = luaS_newudata(L, ${MEM_SIZE}, ${UV_SIZE});
        ${UDATA}->metatable = ${GET_MT_SLOT};
    ]], {
        UDATA_DECL = c_declaration(udata),
        MEM_SIZE = self:mem_size(),
        UV_SIZE = self:gc_size(),
        UDATA = udata.name,
        GET_MT_SLOT = get_slot(metatable_type, mt_slot),
    })
    return cstats, udata.name
end

--
-- code generation
--

local function generate_pallene_entry_point_prototype(tl_node, literals)
    local ctx = Context.new(literals)

    local ret_ctype
    if #tl_node._type.rettypes == 0 then
        ret_ctype = "void"
    else
        ret_ctype = ctype(tl_node._type.rettypes[1])
    end

    local params = {}
    table.insert(params, [[lua_State * L]])
    for _, param in ipairs(tl_node.params) do
        param._cvar = ctx:new_tvar(param._type, param.name)
        table.insert(params, c_declaration(param._cvar))
    end

    local prototype = util.render(
        [[static ${RET} ${NAME}(
            ${PARAMS}
        )]], {
            RET = ret_ctype,
            NAME = tl_node._pallene_entry_point,
            PARAMS = table.concat(params, ",\n")
        })

    return prototype, ctx
end

local function generate_pallene_entry_point(tl_node, literals)
    local prototype, ctx =
        generate_pallene_entry_point_prototype(tl_node, literals)

    local body = {}
    table.insert(body, upvalues_init_local_cvars(ctx))
    table.insert(body, generate_stat(tl_node.block, ctx))

    local reserve_stack = gc_reserve_stack(ctx)

    local out = util.render([[
        ${PROTO}{
            ${RESERVE_STACK}
            ${BODY}
        }
    ]], {
        PROTO = prototype,
        RESERVE_STACK = reserve_stack,
        BODY = table.concat(body, "\n"),
    })
    return out
end

local function generate_lua_entry_point_prototype(tl_node, literals)
    return util.render([[static int ${LUA_ENTRY_POINT}(lua_State *L)]], {
        LUA_ENTRY_POINT = tl_node._lua_entry_point
    })
end

local function generate_lua_entry_point(tl_node, literals)
    local ctx = Context.new(literals)

    local init_upvalues = upvalues_init_local_cvars(ctx)

    local base = ctx:new_cvar("StackValue*")
    local set_base = util.render("${BASE_DECL} = L->ci->func;", {
        BASE_DECL = c_declaration(base)
    })

    local nargs = ctx:new_cvar("int", "nargs")
    local check_nargs = util.render([[
        ${NARGS_DECL} = cast_int(L->top - (${BASE} + 1));
        if (PALLENE_UNLIKELY(${NARGS} != ${EXPECTED})) {
            pallene_runtime_arity_error(L, ${EXPECTED}, ${NARGS});
        }
    ]], {
        BASE = base.name,
        NARGS = nargs.name,
        NARGS_DECL = c_declaration(nargs),
        EXPECTED = c_integer(#tl_node.params),
    })

    local function argslot(i)
        local out = util.render("s2v(${BASE} + ${I})", {
            BASE = base.name,
            I = c_integer(i),
        })
        return out
    end

    -- TODO: fix: the error message is not able specify if the
    -- given type is float or integer (it prints "number")
    local check_types = {}
    for i, param in ipairs(tl_node.params) do
        local slot = ctx:new_cvar("TValue*")
        table.insert(check_types, util.render([[
            ${SLOT_DECL} = ${SLOT_ADDRESS};
            if (PALLENE_UNLIKELY(!${CHECK_TAG})) {
                pallene_runtime_argument_type_error(L, ${PARAM_NAME}, ${LINE}, ${EXPECTED_TAG}, ${SLOT_NAME});
            }
        ]], {
            SLOT_NAME = slot.name,
            SLOT_DECL = c_declaration(slot),
            SLOT_ADDRESS = argslot(i),
            CHECK_TAG = check_tag(param._type, slot.name, ctx),
            PARAM_NAME = c_string(param.name),
            LINE = c_integer(param.loc.line),
            EXPECTED_TAG = pallene_type_tag(param._type),
        }))
    end

    local arg_vars  = {}
    local get_args = {}
    for i, param in ipairs(tl_node.params) do
        local arg = ctx:new_tvar(param._type)
        table.insert(arg_vars, arg)
        table.insert(get_args, util.render([[
            ${ARG_DECL} = ${SLOT_VALUE};
        ]], {
            ARG_DECL = c_declaration(arg),
            SLOT_VALUE = get_slot(param._type, argslot(i)),
        }))
    end

    local pallene_args = {"L"}
    for _, var in ipairs(arg_vars) do
        table.insert(pallene_args, var.name)
    end
    local pallene_call = util.render("${PALLENE_ENTRY_POINT}(${ARGS})", {
        PALLENE_ENTRY_POINT = tl_node._pallene_entry_point,
        ARGS = table.concat(pallene_args, ", "),
    })

    local set_return
    if #tl_node._type.rettypes == 0 then
        set_return = util.render([[
            ${PALLENE_CALL};
        ]], {
            PALLENE_CALL = pallene_call,
        })
    elseif #tl_node._type.rettypes == 1 then
        local ret_typ = tl_node._type.rettypes[1]
        local ret = ctx:new_cvar(ctype(ret_typ), "ret")
        local push_ret = push_to_stack(ctx, ret_typ, ret.name)
        set_return = util.render([[
            ${RET_DECL} = ${PALLENE_CALL};
            ${PUSH_RET}
        ]], {
            PALLENE_CALL = pallene_call,
            RET_DECL = c_declaration(ret),
            PUSH_RET = push_ret,
        })
    else
        error("not implemented")
    end

    -- Todo: This is a regular Lua function call so we only need to call
    -- checkstack if we need >= 20 slots.
    local reserve_stack = gc_reserve_stack(ctx)

    local out = util.render([[
        ${PROTO}
        {
            ${RESERVE_STACK}
            ${INIT_UPVALUES}
            ${SET_BASE}
            ${CHECK_NARGS}
            ${CHECK_TYPES}
            ${GET_ARGS}
            ${SET_RETURN}
            return ${NRET};
        }
    ]], {
        PROTO = generate_lua_entry_point_prototype(tl_node, literals),
        RESERVE_STACK = reserve_stack,
        INIT_UPVALUES = init_upvalues,
        SET_BASE = set_base,
        CHECK_NARGS = check_nargs,
        CHECK_TYPES = table.concat(check_types, "\n"),
        GET_ARGS = table.concat(get_args, "\n"),
        SET_RETURN = set_return,
        NRET = c_integer(#tl_node._type.rettypes),
    })
    return out
end

local function generate_upvalue_literal(lit, ctx)
    local typ = types.T.String()
    local s = ctx:new_tvar(typ)
    local cstats = util.render([[
        ${S_DECL} = luaS_new(L, ${STRLIT});
    ]], {
        S_DECL = c_declaration(s),
        STRLIT = c_string(lit),
    })
    return typ, cstats, s.name
end

local function generate_upvalue_modvar(tl_node, ctx)
    local typ, cstats, cvalue

    local tag = tl_node._tag
    if     tag == ast.Toplevel.Func then
        local closure = ctx:new_cvar("CClosure*")
        local func    = ctx:new_cvar("TValue")
        typ = tl_node._type
        cstats = util.render([[
            ${CLOSURE_DECL} = luaF_newCclosure(L, 1);
            ${CLOSURE}->f = ${LUA_ENTRY_POINT};
            setuvalue(L, &${CLOSURE}->upvalue[0], ${UPVALUES});
            ${FUNC_DECL}; setclCvalue(L, &${FUNC}, ${CLOSURE});
        ]],{
            LUA_ENTRY_POINT = tl_node._lua_entry_point,
            UPVALUES = upvalues_table(ctx),
            CLOSURE = closure.name,
            CLOSURE_DECL = c_declaration(closure),
            FUNC = func.name,
            FUNC_DECL = c_declaration(func),
        })
        cvalue = func.name

    elseif tag == ast.Toplevel.Var then
        local exp = tl_node.value
        typ = exp._type
        cstats, cvalue = generate_exp(exp, ctx)

    elseif tag == ast.Toplevel.Record then
        typ = metatable_type
        cstats, cvalue = tl_node._rec:create_metatable(ctx)

    else
        error("impossible")
    end

    local upvname = string.format("/* %s */\n", ast.toplevel_name(tl_node))
    return typ, upvname .. cstats, cvalue
end

local function generate_upvalue(upv, ctx)
    local tag = upv._tag
    if     tag == upvalues.T.Literal then
        return generate_upvalue_literal(upv.lit, ctx)
    elseif tag == upvalues.T.ModVar then
        return generate_upvalue_modvar(upv.tl_node, ctx)
    else
        error("impossible")
    end
end

local function generate_luaopen_upvalues(prog, ctx)
    local parts = {}

    for i, upv in ipairs(prog._upvalues) do
        ctx:begin_scope()
        local typ, cstats, cvalue = generate_upvalue(upv, ctx)
        local slot = upvalues_slot(i, ctx)
        local upv_table = upvalues_table(ctx)
        local setslot = set_heap_slot(typ, slot, cvalue, upv_table)
        table.insert(parts, cstats)
        table.insert(parts, setslot)
        ctx:end_scope()
    end

    return table.concat(parts, "\n")
end

local function generate_luaopen_exports_table(prog, ctx)
    local n_exported_functions = 0
    for _, tl_node in ipairs(prog) do
        if tl_node._tag == ast.Toplevel.Func and not tl_node.islocal then
            n_exported_functions = n_exported_functions + 1
        end
    end

    local parts = {}

    table.insert(parts, gc_save_vars(ctx)) -- createtable may call gc

    ctx:reserve_slots(3)
    table.insert(parts, util.render([[
        lua_createtable(L, 0, ${N});
    ]], {
        N = c_integer(n_exported_functions),
    }))
    for _, tl_node in ipairs(prog) do
        if tl_node._tag == ast.Toplevel.Func and not tl_node.islocal then
            table.insert(parts,
                util.render([[
                    lua_pushstring(L, ${NAME});
                    setobj(L, s2v(L->top), ${SLOT}); api_incr_top(L);
                    lua_settable(L, -3);
                ]], {
                    NAME = c_string(ast.toplevel_name(tl_node)),
                    SLOT = upvalues_slot(tl_node._upvalue_index, ctx),
                })
            )
        end
    end
    ctx:free_slots(3)

    -- Don't free the vars because the table we want to return is still on top
    -- and we are already returning anyway...
    --table.insert(parts, gc_release_vars(ctx))

    return table.concat(parts, "\n")
end

local function generate_luaopen(prog, modname)
    local ctx = Context.new(prog._literals)

    local body = {}

    table.insert(body, "/* Allocate upvalue table */")
    table.insert(body, "/* ---------------------- */")
    table.insert(body, upvalues_create_table(#prog._upvalues, ctx))

    table.insert(body, "/* Initialize upvalues */")
    table.insert(body, "/* ------------------- */")
    table.insert(body, generate_luaopen_upvalues(prog, ctx))

    table.insert(body, "/* Create exports table */")
    table.insert(body, "/* -------------------- */")
    table.insert(body, generate_luaopen_exports_table(prog, ctx))

    -- TODO: make this reserve_stack optional
    -- (see similar comment in lua entry point)
    local reserve_stack = gc_reserve_stack(ctx)

    local out = util.render([[
        int luaopen_${MODNAME}(lua_State *L)
        {
            ${RESERVE_STACK}
            ${BODY}
            return 1;
        }
    ]], {
        MODNAME = modname,
        RESERVE_STACK = reserve_stack,
        BODY = table.concat(body, "\n"),
    })
    return out
end

declare_type("Lvalue", {
    CVar       = {"var", "varname"},
    ArraySlot  = {"var", "t_varname", "i_varname"},
    GlobalVar  = {"var", "upvalue_index"},
    RecGcSlot  = {"var", "slot_address", "udata_pointer"},
})

-- @returns C statements, C rvalue
-- (like generate_exp)
local function generate_lvalue_read(lvalue, ctx)
    local tag = lvalue._tag
    if     tag == coder.Lvalue.CVar then
        return "", lvalue.varname

    elseif tag == coder.Lvalue.ArraySlot then
        local typ = lvalue.var._type
        local loc = lvalue.var.loc
        local ui = ctx:new_cvar("lua_Unsigned", "ui")
        local arrslot = ctx:new_cvar("const TValue *", "arrslot")
        local out = ctx:new_tvar(typ)
        local cstats = util.render([[
            ${UI_DECL} = ((lua_Unsigned)${I}) - 1;
            if (PALLENE_UNLIKELY(${UI} >= ${T}->sizearray)) {
                pallene_renormalize_array(L, ${T}, ${UI}, ${LINE});
            }
            ${ARRSLOT_DECL} = &${T}->array[${UI}];
            if (PALLENE_UNLIKELY(!${CHECK_TAG})) {
                pallene_runtime_array_type_error(L, ${LINE}, ${EXPECTED_TAG}, rawtt(${ARRSLOT}));
            }
            ${OUT_DECL} = ${GET_ARRSLOT};
        ]], {
            T = lvalue.t_varname,
            I = lvalue.i_varname,
            UI = ui.name,
            UI_DECL = c_declaration(ui),
            ARRSLOT = arrslot.name,
            ARRSLOT_DECL = c_declaration(arrslot),
            OUT_DECL = c_declaration(out),
            CHECK_TAG = check_tag(typ, arrslot.name, ctx),
            EXPECTED_TAG = pallene_type_tag(typ),
            LINE = loc.line,
            COL = loc.col,
            GET_ARRSLOT = get_slot(typ, arrslot.name),
        })
        return cstats, out.name

    elseif tag == coder.Lvalue.GlobalVar then
        local typ = lvalue.var._type
        local slot = ctx:new_cvar("TValue *")
        local out = ctx:new_tvar(typ)
        local cstats = util.render([[
            ${SLOT_DECL} = ${UPV_SLOT};
            ${OUT_DECL} = ${GET_SLOT};
        ]], {
            SLOT_DECL = c_declaration(slot),
            UPV_SLOT = upvalues_slot(lvalue.upvalue_index, ctx),
            OUT_DECL = c_declaration(out),
            GET_SLOT = get_slot(typ, slot.name),
        })
        return cstats, out.name

    elseif tag == coder.Lvalue.RecGcSlot then
        local typ = lvalue.var._type
        local out = ctx:new_tvar(typ)
        local cstats = util.render([[
            ${OUT_DECL} = ${GET_SLOT};
        ]], {
            OUT_DECL = c_declaration(out),
            GET_SLOT = get_slot(typ, lvalue.slot_address),
        })
        return cstats, out.name

    else
        error("impossible")
    end
end

-- @returns C statements
-- (like generate_stat)
local function generate_lvalue_write(lvalue, exp_cvalue, ctx)
    local tag = lvalue._tag
    if     tag == coder.Lvalue.CVar then
        local out = util.render([[
            ${X} = ${VALUE};
        ]], {
            X = lvalue.varname,
            VALUE = exp_cvalue,
        })
        return out

    elseif tag == coder.Lvalue.ArraySlot then
        -- TODO: GC
        local typ = lvalue.var._type
        local ui = ctx:new_cvar("lua_Unsigned", "ui")
        local slot = ctx:new_cvar("TValue *", "slot")
        local out = util.render([[
            ${UI_DECL} = ((lua_Unsigned)${I}) - 1;
            if (PALLENE_UNLIKELY(${UI} >= ${T}->sizearray)) {
                pallene_renormalize_array(L, ${T}, ${UI}, ${LINE});
            }
            ${SLOT_DECL} = &${T}->array[${UI}];
            ${SET_SLOT}
        ]], {
            T = lvalue.t_varname,
            I = lvalue.i_varname,
            UI = ui.name,
            UI_DECL = c_declaration(ui),
            SLOT_DECL = c_declaration(slot),
            SET_SLOT = set_heap_slot(
                typ, slot.name, exp_cvalue, lvalue.t_varname),
            LINE = lvalue.var.loc.line,
        })
        return out

    elseif tag == coder.Lvalue.GlobalVar then
        local typ = lvalue.var._type
        local slot = ctx:new_cvar("TValue *")
        local out = util.render([[
            ${SLOT_DECL} = ${UPV_SLOT};
            ${SET_SLOT}
        ]], {
            SLOT_DECL = c_declaration(slot),
            UPV_SLOT = upvalues_slot(lvalue.upvalue_index, ctx),
            SET_SLOT = set_heap_slot(
                typ, slot.name, exp_cvalue, upvalues_table(ctx)),
        })
        return out

    elseif tag == coder.Lvalue.RecGcSlot then
        local typ = lvalue.var._type
        local slot = ctx:new_cvar("TValue *")
        local out = util.render([[
            ${SLOT_DECL} = ${SLOT_VALUE};
            ${SET_SLOT}
        ]], {
            SLOT_DECL = c_declaration(slot),
            SLOT_VALUE = lvalue.slot_address,
            SET_SLOT = set_heap_slot(
                typ, slot.name, exp_cvalue, lvalue.udata_pointer),
        })
        return out

    else
        error("impossible")
    end
end


-- @param prog: (ast) Annotated AST for the whole module
-- @param modname: (string) Lua module name (for luaopen)
-- @return (string) C code for the whole module
generate_program = function(prog, modname)
    -- Records
    local structs = {}
    for _, tl_node in ipairs(prog) do
        if tl_node._tag == ast.Toplevel.Record then
            tl_node._rec = RecordCoder.new(tl_node)
            table.insert(structs, tl_node._rec:make_declarations())
        end
    end

    -- Name all the function entry points
    for _, tl_node in ipairs(prog) do
        if tl_node._tag == ast.Toplevel.Func then
            tl_node._pallene_entry_point =
                function_name(tl_node.name, "pallene")
            tl_node._lua_entry_point =
                function_name(tl_node.name, "lua")
        end
    end

    -- Create toplevel function declarations
    local declare_functions
    do
        local function_declarations = {}
        for _, tl_node in ipairs(prog) do
            if tl_node._tag == ast.Toplevel.Func then
                assert(#tl_node._type.rettypes <= 1)
                table.insert(function_declarations,
                    generate_pallene_entry_point_prototype(tl_node, prog._literals)..";")
                table.insert(function_declarations,
                    generate_lua_entry_point_prototype(tl_node, prog._literals)..";")
            end
        end
        declare_functions = table.concat(function_declarations, "\n")
    end


    -- Create toplevel function definitions
    local define_functions
    do
        local function_definitions = {}
        for _, tl_node in ipairs(prog) do
            if tl_node._tag == ast.Toplevel.Func then
                assert(#tl_node._type.rettypes <= 1)
                table.insert(function_definitions,
                    generate_pallene_entry_point(tl_node, prog._literals))
                table.insert(function_definitions,
                    generate_lua_entry_point(tl_node, prog._literals))
            end
        end
        define_functions = table.concat(function_definitions, "\n")
    end

    local luaopen_function = generate_luaopen(prog, modname)

    local code = util.render(whole_file_template, {
        STRUCTS = table.concat(structs, "\n\n"),
        DECLARE_FUNCTIONS = declare_functions,
        DEFINE_FUNCTIONS = define_functions,
        LUAOPEN_FUNCTION = luaopen_function,
    })
    return pretty.reindent_c(code)
end

-- @param stat: (ast.Stat)
-- @return (string) C statements
generate_stat = function(stat, ctx)
    local tag = stat._tag
    if     tag == ast.Stat.Block then
        ctx:begin_scope()
        local cstatss = {}
        table.insert(cstatss, "{")
        for _, inner_stat in ipairs(stat.stats) do
            table.insert(cstatss, generate_stat(inner_stat, ctx))
        end
        table.insert(cstatss, "}")
        ctx:end_scope()
        return table.concat(cstatss, "\n")

    elseif tag == ast.Stat.While then
        ctx:begin_scope()
        local cond_cstats, cond_cvalue = generate_exp(stat.condition, ctx)
        local block_cstats = generate_stat(stat.block, ctx)
        ctx:end_scope()
        local out = util.render([[
            for(;;) {
                ${COND_STATS}
                if (!${COND}) break;
                ${BLOCK}
            }
        ]], {
            COND_STATS = cond_cstats,
            COND = cond_cvalue,
            BLOCK = block_cstats
        })
        return out

    elseif tag == ast.Stat.Repeat then
        ctx:begin_scope()
        local block_cstats = generate_stat(stat.block, ctx)
        local cond_cstats, cond_cvalue = generate_exp(stat.condition, ctx)
        ctx:end_scope()
        local out = util.render([[
            for(;;){
                ${BLOCK}
                ${COND_STATS}
                if (${COND}) break;
            }
        ]], {
            COND_STATS = cond_cstats,
            COND = cond_cvalue,
            BLOCK = block_cstats,
        })
        return out

    elseif tag == ast.Stat.If then
        ctx:begin_scope()
        local cond_cstats, cond_cvalue = generate_exp(stat.condition, ctx)
        local then_cstats = generate_stat(stat.then_, ctx)
        local else_cstats = generate_stat(stat.else_, ctx)
        ctx:end_scope()

        local cstats = util.render(
            [[{
                ${COND_STATS}
                if (${COND}) ${THEN} else ${ELSE}
            }]], {
            COND_STATS = cond_cstats,
            COND = cond_cvalue,
            THEN = then_cstats,
            ELSE = else_cstats,
        })
        return cstats

    elseif tag == ast.Stat.For then
        ctx:begin_scope()
        local typ = stat.decl._type

        local start_cstats, start_cvalue = generate_exp(stat.start, ctx)
        local start = ctx:new_tvar(typ, "start")

        local limit_cstats, limit_cvalue = generate_exp(stat.limit, ctx)
        local limit = ctx:new_tvar(typ, "limit")

        local step_cstats, step_cvalue = generate_exp(stat.step, ctx)
        local step = ctx:new_tvar(typ, "step")

        stat.decl._cvar = ctx:new_tvar(typ, stat.decl.name)

        local block_cstats = generate_stat(stat.block, ctx)

        local render_names = {
            STEP = step.name,
            START = start.name,
            LIMIT = limit.name,
        }

        -- TODO: remove ternary operator when step is a constant
        local loop_cond = util.render(
            [[(${STEP} >= 0 ? ${START} <= ${LIMIT} : ${START} >= ${LIMIT})]],
            render_names)

        local loop_step
        if typ._tag == types.T.Integer then
            loop_step = util.render([[${START} = intop(+, ${START}, ${STEP});]],
                render_names)
        elseif typ._tag == types.T.Float then
            loop_step = util.render([[${START} = ${START} + ${STEP};]],
                render_names)
        else
            error("impossible")
        end

        ctx:end_scope()
        local out = util.render([[
            ${START_STAT}
            ${LIMIT_STAT}
            ${STEP_STAT}
            ${START_DECL} = ${START_VALUE};
            ${LIMIT_DECL} = ${LIMIT_VALUE};
            ${STEP_DECL} = ${STEP_VALUE};
            while (${LOOP_COND}) {
                ${LOOPVAR_DECL} = ${START};
                (void) ${LOOPVAR};
                ${BLOCK}
                ${LOOP_STEP}
            }
        ]], {
            START = start.name,
            START_STAT  = start_cstats,
            START_VALUE = start_cvalue,
            START_DECL  = c_declaration(start),
            LIMIT_STAT  = limit_cstats,
            LIMIT_VALUE = limit_cvalue,
            LIMIT_DECL  = c_declaration(limit),
            STEP_STAT  = step_cstats,
            STEP_VALUE = step_cvalue,
            STEP_DECL  = c_declaration(step),
            LOOP_COND = loop_cond,
            LOOP_STEP = loop_step,
            LOOPVAR      = stat.decl._cvar.name,
            LOOPVAR_DECL = c_declaration(stat.decl._cvar),
            BLOCK = block_cstats,
        })
        return out

    elseif tag == ast.Stat.Assign then
        ctx:begin_scope()
        local var_cstats, lvalue = generate_var(stat.var, ctx)
        local exp_cstats, exp_cvalue = generate_exp(stat.exp, ctx)
        local lvalue_cstats = generate_lvalue_write(lvalue, exp_cvalue, ctx)
        ctx:end_scope()
        local cstats = util.render([[
            ${VAR_CSTATS}
            ${EXP_CSTATS}
            ${LVALUE_CSTATS}
        ]], {
            VAR_CSTATS = var_cstats,
            EXP_CSTATS = exp_cstats,
            LVALUE_CSTATS = lvalue_cstats,
        })
        return cstats

    elseif tag == ast.Stat.Decl then
        ctx:begin_scope()
        local exp_cstats, exp_cvalue = generate_exp(stat.exp, ctx)
        ctx:end_scope() -- (don't put the tvar inside this scope!)
        stat.decl._cvar = ctx:new_tvar(stat.decl._type, stat.decl.name)
        local out = util.render([[
            ${STATS}
            ${DECLARATION} = ${VALUE};
        ]], {
            STATS = exp_cstats,
            VALUE = exp_cvalue,
            DECLARATION = c_declaration(stat.decl._cvar),
        })
        return out

    elseif tag == ast.Stat.Call then
        ctx:begin_scope()
        local cstats, cvalue = generate_exp(stat.callexp, ctx)

        local ignore_result
        if stat.callexp._type._tag == types.T.Void then
            ignore_result = ""
        else
            ignore_result = "(void) " .. cvalue .. ";"
        end
        ctx:end_scope()

        local out = util.render([[
            ${STATS}
            ${IGNORE_RESULT}
        ]], {
            STATS = cstats,
            IGNORE_RESULT = ignore_result
        })
        return out

    elseif tag == ast.Stat.Return then
        assert(#stat.exps <= 1)
        ctx:begin_scope()
        local cstats, cvalue
        if #stat.exps == 0 then
            cstats = ""
            cvalue = ""
        else
            cstats, cvalue = generate_exp(stat.exps[1], ctx)
        end
        ctx:end_scope()
        local out = util.render([[
            ${CSTATS}
            return ${CVALUE};
        ]], {
            CSTATS = cstats,
            CVALUE = cvalue
        })
        return out

    else
        error("impossible")
    end
end

-- @param var: (ast.Var)
-- @returns (string, coder.Lvalue) C Statements, and a lvalue
--
-- The lvalue should not not contain side-effects. Anything that could care
-- about evaluation order should be returned as part of the first argument.
generate_var = function(var, ctx)
    local tag = var._tag
    if     tag == ast.Var.Name then
        local decl = var._decl
        if    decl._tag == ast.Decl.Decl then
            return "", coder.Lvalue.CVar(var, decl._cvar.name)

        elseif decl._tag == ast.Toplevel.Var or
                decl._tag == ast.Toplevel.Func
        then
            return "", coder.Lvalue.GlobalVar(var, decl._upvalue_index)

        else
            error("impossible")
        end

    elseif tag == ast.Var.Bracket then
        local t_cstats, t_cvalue = generate_exp(var.exp1, ctx)
        local k_cstats, k_cvalue = generate_exp(var.exp2, ctx)
        local cstats = t_cstats .. "\n" .. k_cstats
        return cstats, coder.Lvalue.ArraySlot(var, t_cvalue, k_cvalue)

    elseif tag == ast.Var.Dot then
        local tl_node = var.exp._type.type_decl
        local cstats, udata = generate_exp(var.exp)
        local slot, typ = tl_node._rec:field_slot(udata, var.name)
        if types.is_gc(typ) then
            return cstats, coder.Lvalue.RecGcSlot(var, slot, udata)
        else
            return cstats, coder.Lvalue.CVar(var, slot)
        end

    else
        error("impossible")
    end
end

local function generate_exp_builtin_io_write(exp, ctx)
    local args = exp.args
    assert(#args == 1)
    local cstats_s, cvalue_s = generate_exp(args[1], ctx)
    local f = ctx:new_cvar("FILE *")
    local chars = ctx:new_cvar("const char *")
    local len = ctx:new_cvar("size_t")
    local cstats = util.render([[
        ${CSTATS_S}
        ${F_DECL} = stdout; /* TODO: use Lua output file */
        ${CHARS_DECL} = getstr(${S});
        ${LEN_DECL} = tsslen(${S});
        fwrite(${CHARS}, sizeof(char), ${LEN}, ${F});
    ]], {
        S = cvalue_s,
        CSTATS_S = cstats_s,
        F = f.name,
        F_DECL = c_declaration(f),
        CHARS = chars.name,
        CHARS_DECL = c_declaration(chars),
        LEN = len.name,
        LEN_DECL = c_declaration(len),
    })
    return cstats, "VOID"
end

local function generate_exp_builtin_table_insert(exp, ctx)
    local args = exp.args
    assert(#args == 2)
    local cstats_t, cvalue_t = generate_exp(args[1], ctx)
    local cstats_v, cvalue_v = generate_exp(args[2], ctx)
    local ui = ctx:new_cvar("lua_Unsigned", "ui")
    local slot = ctx:new_cvar("TValue *", "slot")
    --local cond_gc = gc_cond_gc(ctx) --TODO
    local cstats = util.render([[
        ${CSTATS_T}
        ${CSTATS_V}
        ${UI_DECL} = luaH_getn(${CVALUE_T});
        if (PALLENE_UNLIKELY(${UI} >= ${CVALUE_T}->sizearray)) {
            pallene_renormalize_array(L, ${CVALUE_T}, ${UI}, ${LINE});
        }
        ${SLOT_DECL} = &${CVALUE_T}->array[${UI}];
        ${SET_SLOT}
    ]], {
        CSTATS_T = cstats_t,
        CVALUE_T = cvalue_t,
        CSTATS_V = cstats_v,
        CVALUE_V = cvalue_v,
        UI = ui.name,
        UI_DECL = c_declaration(ui),
        LINE = exp.loc.line,
        SLOT_DECL = c_declaration(slot),
        SET_SLOT = set_heap_slot(args[2]._type, slot.name, cvalue_v, cvalue_t),
    })
    return cstats, "VOID"
end

local function generate_exp_builtin_table_remove(exp, ctx)
    local args = exp.args
    assert(#args == 1)
    local cstats_t, cvalue_t = generate_exp(args[1])
    local ui = ctx:new_cvar("lua_Unsigned", "ui")
    local slot = ctx:new_cvar("TValue *", "slot")
    local cstats = util.render([[
        ${CSTATS_T}
        ${UI_DECL} = luaH_getn(${CVALUE_T});
        if (PALLENE_LIKELY(${UI} > 0)) {
            ${UI} = ${UI} - 1;
            if (PALLENE_UNLIKELY(${UI} >= ${CVALUE_T}->sizearray)) {
                pallene_renormalize_array(L, ${CVALUE_T}, ${UI}, ${LINE});
            }
            ${SLOT_DECL} = &${CVALUE_T}->array[${UI}];
            setempty(${SLOT});
        }
    ]], {
        CSTATS_T = cstats_t,
        CVALUE_T = cvalue_t,
        UI = ui.name,
        UI_DECL = c_declaration(ui),
        SLOT = slot.name,
        LINE = exp.loc.line,
        SLOT_DECL = c_declaration(slot),
    })
    return cstats, "VOID"
end


local function generate_unop(op, exp, ctx)
    local x_stats, x_var = generate_exp(exp.exp, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${R_DECL} = ${OP} ${X};
    ]], {
        OP = op,
        X = x_var,
        X_STATS = x_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

-- Relational operators, and basic float operations have the same semantics in C
-- and in Lua / Pallene.
local function generate_binop(op, exp, ctx)
    local x_stats, x_var = generate_exp(exp.lhs, ctx)
    local y_stats, y_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${Y_STATS}
        ${R_DECL} = ${X} ${OP} ${Y};
    ]], {
        OP = op,
        X = x_var,
        X_STATS = x_stats,
        Y = y_var,
        Y_STATS = y_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

-- For integer arithmetic operators Lua/Pallene mandates well-defined
-- two's-compliment wraparound in case of overflow.
local function generate_intop(op, exp, ctx)
    local x_stats, x_var = generate_exp(exp.lhs, ctx)
    local y_stats, y_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${Y_STATS}
        ${R_DECL} = intop(${OP}, ${X}, ${Y});
    ]], {
        OP = op,
        X = x_var,
        X_STATS = x_stats,
        Y = y_var,
        Y_STATS = y_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

local function generate_unop_arraylen(exp, ctx)
    local cstats, cvalue = generate_exp(exp.exp, ctx)
    local tmp = ctx:new_cvar("lua_Integer")
    local cstats_op = util.render([[
        ${CSTATS}
        ${TMP_DECL} = luaH_getn(${CVALUE});
    ]], {
        CSTATS = cstats,
        CVALUE = cvalue,
        TMP_DECL = c_declaration(tmp),
    })
    return cstats_op, tmp.name
end

local function generate_unop_strlen(exp, ctx)
    local cstats, cvalue = generate_exp(exp.exp, ctx)
    local tmp = ctx:new_cvar("lua_Integer")
    local cstats_op = util.render([[
        ${TMP_DECL} = tsslen(${CVALUE});
    ]], {
        CSTATS = cstats,
        CVALUE = cvalue,
        TMP_DECL = c_declaration(tmp),
    })
    return cstats_op, tmp.name
end

local function generate_unop_intneg(exp, ctx)
    local x_stats, x_var = generate_exp(exp.exp, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${R_DECL} = intop(-, 0, ${X});
    ]], {
        X = x_var,
        X_STATS = x_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

-- Lua/Pallene integer division rounds to negative infinity instead of towards
-- zero. We inline luaV_div here to give the C compiler more optimization
-- opportunities (see that function for comments on how it works).
local function generate_binop_idiv_int(exp, ctx)
    local m_stats, m_var = generate_exp(exp.lhs, ctx)
    local n_stats, n_var = generate_exp(exp.rhs, ctx)
    local q = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${M_STATS}
        ${N_STATS}
        ${Q_DECL};
        if (l_castS2U(${N}) + 1u <= 1u) {
            if (${N} == 0){
                pallene_runtime_divide_by_zero_error(L, ${LINE});
            } else {
                ${Q} = intop(-, 0, ${M});
            }
        } else {
            ${Q} = ${M} / ${N};
            if ((${M} ^ ${N}) < 0 && ${M} % ${N} != 0) {
                ${Q} -= 1;
            }
        }
    ]], {
        M = m_var,
        M_STATS = m_stats,
        N = n_var,
        N_STATS = n_stats,
        Q = q.name,
        Q_DECL = c_declaration(q),
        LINE = c_integer(exp.loc.line),
    })
    return cstats, q.name
end

-- Lua/Pallene guarantees that (m == n*(m//n) + (,%n))
-- See generate binop_intdiv and luaV_mod
local function generate_binop_mod_int(exp, ctx)
    local m_stats, m_var = generate_exp(exp.lhs, ctx)
    local n_stats, n_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${M_STATS}
        ${N_STATS}
        ${R_DECL};
        if (l_castS2U(${N}) + 1u <= 1u) {
            if (${N} == 0){
                pallene_runtime_mod_by_zero_error(L, ${LINE});
            } else {
                ${R} = 0;
            }
        } else {
            ${R} = ${M} % ${N};
            if (${R} != 0 && (${M} ^ ${N}) < 0) {
                ${R} += ${N};
            }
        }
    ]], {
        M = m_var,
        M_STATS = m_stats,
        N = n_var,
        N_STATS = n_stats,
        R = r.name,
        R_DECL = c_declaration(r),
        LINE = c_integer(exp.loc.line),
    })
    return cstats, r.name
end

-- see luai_numidiv
local function generate_binop_idiv_flt(exp, ctx)
    local x_stats, x_var = generate_exp(exp.lhs, ctx)
    local y_stats, y_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${Y_STATS}
        ${R_DECL} = floor(${X} / ${Y});
    ]], {
        X = x_var,
        X_STATS = x_stats,
        Y = y_var,
        Y_STATS = y_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

-- see luai_numpow
local function generate_binop_pow(exp, ctx)
    local x_stats, x_var = generate_exp(exp.lhs, ctx)
    local y_stats, y_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${Y_STATS}
        ${R_DECL} = pow(${X}, ${Y});
    ]], {
        X = x_var,
        X_STATS = x_stats,
        Y = y_var,
        Y_STATS = y_stats,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

-- In Lua and Pallene, the shift ammount in a bitshift can be any integer, but in
-- C shift ammount must be a positive number less than the width of the integer
-- type being shifted. This means that we need some if statements to implement
-- the Lua shift semantics in C.
--
-- Most of the time, the shift amount should be a constant, which will allow the
-- C compiler to eliminate all of these branches as dead code and generate code
-- that is just as good as a raw C bitshift without the extra Lua semantics.
--
-- For the dynamic case, we gain a bit of performance (~20%) compared to the
-- algorithm in luaV_shiftl by reordering the branches to put the common case
-- (shift ammount is a small positive integer) under only one level of branching
-- and with a PALLENE_LIKELY annotation.
local function generate_binop_shift(shift_pos, shift_neg, exp, ctx)
    local x_stats, x_var = generate_exp(exp.lhs, ctx)
    local y_stats, y_var = generate_exp(exp.rhs, ctx)
    local r = ctx:new_tvar(exp._type)
    local cstats = util.render([[
        ${X_STATS}
        ${Y_STATS}
        ${R_DECL};
        if (PALLENE_LIKELY(l_castS2U(${Y}) < PALLENE_LUAINTEGER_NBITS)) {
            ${R} = intop(${SHIFT_POS}, ${X}, ${Y});
        } else {
            if (l_castS2U(-${Y}) < PALLENE_LUAINTEGER_NBITS) {
                ${R} = intop(${SHIFT_NEG}, ${X}, -${Y});
            } else {
                ${R} = 0;
            }
        }
    ]], {
        SHIFT_POS = shift_pos,
        SHIFT_NEG = shift_neg,
        X = x_var,
        X_STATS = x_stats,
        Y = y_var,
        Y_STATS = y_stats,
        R = r.name,
        R_DECL = c_declaration(r),
    })
    return cstats, r.name
end

local function generate_concat(exp, ctx)
    local gc = gc_cond_gc(ctx)
    local init_parts = {}
    for i, s_exp in ipairs(exp.exps) do
        local s_stats, s_value = generate_exp(s_exp, ctx)
        table.insert(init_parts, util.render([[
            ${S_STATS}
            ss[${i_minus_1}] = ${S_VALUE};
        ]], {
            i_minus_1 = c_integer(i-1),
            S_STATS = s_stats,
            S_VALUE = s_value,
        }))
    end
    local out = ctx:new_tvar(types.T.String())
    local cstats = util.render([[
        ${OUT_DECL};
        {
            ${GC}
            TString *ss[${N}];
            ${INIT};
            ${OUT} = pallene_string_concatN(L, ${N}, ss);
        }
    ]], {
        GC = gc,
        N = c_integer(#exp.exps),
        OUT = out.name,
        OUT_DECL = c_declaration(out),
        INIT = table.concat(init_parts, "\n"),
    })
    return cstats, out.name
end

-- @param exp: (ast.Exp)
-- @returns (string, string) C statements, C rvalue
--
-- The rvalue should not not contain side-effects. Anything that could care
-- about evaluation order should be returned as part of the first argument.
generate_exp = function(exp, ctx)
    local tag = exp._tag
    if     tag == ast.Exp.Nil then
        return "", c_integer(0)

    elseif tag == ast.Exp.Bool then
        return "", c_boolean(exp.value)

    elseif tag == ast.Exp.Integer then
        return "", c_integer(exp.value)

    elseif tag == ast.Exp.Float then
        return "", c_float(exp.value)

    elseif tag == ast.Exp.String then
        return literal_get(exp.value, ctx)

    elseif tag == ast.Exp.Initlist then
        if exp._type._tag == types.T.Array then
            local cond_gc = gc_cond_gc(ctx)

            local tbl = ctx:new_tvar(exp._type)
            local array_part = ctx:new_cvar("TValue *")

            local init_cstats = {}
            for i, field in ipairs(exp.fields) do
                local field_cstats, field_cvalue = generate_exp(field.exp, ctx)
                local slot = util.render([[${ARRAY_PART} + ${I}]], {
                    ARRAY_PART = array_part.name,
                    I = c_integer(i - 1)
                })
                table.insert(init_cstats, field_cstats)
                table.insert(init_cstats, set_heap_slot(
                    exp._type.elem, slot, field_cvalue, tbl.name))
            end

            -- Avoid warnings
            if #init_cstats == 0 then
                table.insert(init_cstats, util.render([[
                    (void) ${ARRAY_PART};
                ]], {
                    ARRAY_PART = array_part.name
                }))
            end

            local cstats = util.render([[
                ${COND_GC}
                ${TBL_DECL} = luaH_new(L);
                luaH_resizearray(L, ${TBL}, ${N});
                ${ARRAY_PART_DECL} = ${TBL}->array;
                ${FIELD_INIT}
            ]], {
                TBL = tbl.name,
                TBL_DECL = c_declaration(tbl),
                ARRAY_PART = array_part.name,
                ARRAY_PART_DECL = c_declaration(array_part),
                N = c_integer(#exp.fields),
                FIELD_INIT = table.concat(init_cstats, "\n"),
                COND_GC = cond_gc,
            })

            return cstats, tbl.name

        elseif exp._type._tag == types.T.Record then
            local body = {}
            table.insert(body, gc_cond_gc(ctx))

            local tl_node = exp._type.type_decl
            local cstats, udata = tl_node._rec:create_instance(exp._type, ctx)
            table.insert(body, cstats)

            for _, field in ipairs(exp.fields) do
                local field_cstats, field_cvalue = generate_exp(field.exp, ctx)
                local set_field = tl_node._rec:set_field(
                        udata, field.name, field_cvalue)
                table.insert(body, field_cstats)
                table.insert(body, set_field)
            end

            return table.concat(body, "\n"), udata

        else
            error("impossible")
        end

    elseif tag == ast.Exp.CallFunc then
        local fexp = exp.exp
        local fargs = exp.args

        if fexp._type._tag == types.T.Builtin then
            local builtin_name = fexp._type.builtin_decl.name
            if builtin_name == "io.write" then
                return generate_exp_builtin_io_write(exp, ctx)
            elseif builtin_name == "table.insert" then
                return generate_exp_builtin_table_insert(exp, ctx)
            elseif builtin_name == "table.remove" then
                return generate_exp_builtin_table_remove(exp, ctx)
            else
                error("impossible")
            end
        elseif fexp._tag == ast.Exp.Var and
            fexp.var._tag == ast.Var.Name and
            fexp.var._decl._tag == ast.Toplevel.Func
        then
            -- Directly calling a toplevel function

            local arg_cstatss = {}
            local arg_cvalues = {"L"}
            for _, arg_exp in ipairs(fargs) do
                local cstats, cvalue = generate_exp(arg_exp, ctx)
                table.insert(arg_cstatss, cstats)
                table.insert(arg_cvalues, cvalue)
            end

            local save_vars = gc_save_vars(ctx)

            local tl_node = fexp.var._decl

            local tmp_var, tmp_init
            if #tl_node._type.rettypes == 0 then
                tmp_var = "VOID" -- gives C error if accidentaly used
                tmp_init = ""
            elseif #tl_node._type.rettypes == 1 then
                local rettype = tl_node._type.rettypes[1]
                local tmp = ctx:new_tvar(rettype)
                tmp_var = tmp.name
                tmp_init = c_declaration(tmp) .. " ="
            else
                error("not implemented")
            end

            local release_vars = gc_release_vars(ctx)

            local cstats = util.render([[
                ${ARG_STATS}
                ${SAVE_VARS}
                ${TMP_INIT} ${FUN_NAME}(${ARGS});
                ${RELEASE_VARS}
            ]], {
                FUN_NAME  = tl_node._pallene_entry_point,
                ARG_STATS = table.concat(arg_cstatss, "\n"),
                ARGS      = table.concat(arg_cvalues, ", "),
                TMP_INIT  = tmp_init,
                SAVE_VARS = save_vars,
                RELEASE_VARS = release_vars,
            })
            return cstats, tmp_var

        else
            -- First-class functions and Lua function calls
            local nargs = #fexp._type.params
            local nret = #fexp._type.rettypes

            local to_push = {}
            local function generate(exp_to_push)
                local cstats, cvalue = generate_exp(exp_to_push, ctx)
                -- we don't use ctx:new_tvar because values were already saved
                table.insert(to_push,
                    { typ = exp_to_push._type, cvalue = cvalue })
                return cstats
            end

            local body = {}
            table.insert(body, generate(fexp))
            for _, arg_exp in ipairs(fargs) do
                table.insert(body, generate(arg_exp))
            end

            table.insert(body, gc_save_vars(ctx))

            for _, x in ipairs(to_push) do
                local push = push_to_stack(ctx, x.typ, x.cvalue)
                table.insert(body, push)
            end

            ctx:free_slots(nargs + 1)
            ctx:reserve_slots(nret)
            table.insert(body, util.render([[
                lua_call(L, ${NARGS}, ${NRET});
            ]], {
                NARGS = nargs,
                NRET = nret,
            }))

            local retval
            if nret == 0 then
                retval = "VOID"

            elseif nret == 1 then
                local ret_typ = fexp._type.rettypes[1]
                local slot = ctx:new_cvar("TValue*")
                local ret = ctx:new_tvar(ret_typ)
                retval = ret.name
                table.insert(body, util.render([[
                    ${SLOT_DECL} = s2v(L->top - 1);
                    if (PALLENE_UNLIKELY(!${CHECK_TAG})) {
                        pallene_runtime_function_return_error(L, ${LINE}, ${EXPECTED_TAG}, rawtt(${SLOT}));
                    }
                    ${RET_DECL} = ${GET_SLOT};
                    L->top--;
                ]], {
                    SLOT      = slot.name,
                    SLOT_DECL = c_declaration(slot),
                    CHECK_TAG = check_tag(ret_typ, slot.name, ctx),
                    LINE = c_integer(exp.loc.line),
                    EXPECTED_TAG = pallene_type_tag(ret_typ),
                    RET_DECL = c_declaration(ret),
                    GET_SLOT = get_slot(ret_typ, slot.name),
                }))
            else
                error("not implemented")
            end
            ctx:free_slots(nret)

            table.insert(body, gc_release_vars(ctx))

            local cstats = table.concat(body, "\n")
            return cstats, retval
        end

    elseif tag == ast.CallMethod then
        error("not implemented")

    elseif tag == ast.Exp.Var then
        local var_cstats, lvalue = generate_var(exp.var, ctx)
        local lvalue_cstats, out = generate_lvalue_read(lvalue, ctx)
        local cstats = var_cstats .. "\n" .. lvalue_cstats
        return cstats, out

    elseif tag == ast.Exp.Unop then
        local op = exp.op
        if op == "#" then
            if exp.exp._type._tag == types.T.Array then
                return generate_unop_arraylen(exp, ctx)
            elseif exp.exp._type._tag == types.T.String then
                return generate_unop_strlen(exp, ctx)
            else
                error("impossible")
            end

        elseif op == "-" then
            if     exp._type._tag == types.T.Integer then
                return generate_unop_intneg(exp, ctx)
            elseif exp._type._tag == types.T.Float then
                return generate_unop("-", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "~" then
            return generate_unop("~", exp, ctx)

        elseif op == "not" then
            return generate_unop("!", exp, ctx)

        else
            error("impossible")
        end

    elseif tag == ast.Exp.Concat then
        return generate_concat(exp, ctx)

    elseif tag == ast.Exp.Binop then
        local ltyp = exp.lhs._type._tag
        local rtyp = exp.rhs._type._tag
        local op = exp.op
        if     op == "+" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("+", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("+", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "-" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("-", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("-", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "*" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("*", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("*", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "/" then
            if     ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("/", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "&" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("&", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "|" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("|", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "~" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_intop("^", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "<<" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop_shift("<<", ">>", exp, ctx)
            else
                error("impossible")
            end

        elseif op == ">>" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop_shift(">>", "<<", exp, ctx)
            else
                error("impossible")
            end

        elseif op == "%" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop_mod_int(exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                -- see luai_nummod
                error("not implemented yet")
            else
                error("impossible")
            end

        elseif op == "//" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop_idiv_int(exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop_idiv_flt(exp, ctx)
            else
                error("impossible")
            end

        elseif op == "^" then
            if     ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop_pow(exp, ctx)
            else
                error("impossible")
            end

        elseif op == "==" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop("==", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("==", exp, ctx)
            else
                error("not implemented yet")
            end

        elseif op == "~=" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop("!=", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("!=", exp, ctx)
            else
                error("not implemented yet")
            end

        elseif op == "<" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop("<", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("<", exp, ctx)
            elseif ltyp == types.T.String and rtyp == types.T.String then
                error("not implemented yet")
            elseif ltyp == types.T.Integer and rtyp == types.T.Float then
                error("not implemented yet") -- see LTnum
            elseif ltyp == types.T.Float and rtyp == types.T.Integer then
                error("not implemented yet") -- see LTnum
            else
                error("impossible")
            end

        elseif op == ">" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop(">", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop(">", exp, ctx)
            elseif ltyp == types.T.String and rtyp == types.T.String then
                error("not implemented yet")
            elseif ltyp == types.T.Integer and rtyp == types.T.Float then
                error("not implemented yet") -- see LTnum
            elseif ltyp == types.T.Float and rtyp == types.T.Integer then
                error("not implemented yet") -- see LTnum
            else
                error("impossible")
            end

        elseif op == "<=" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop("<=", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop("<=", exp, ctx)
            elseif ltyp == types.T.String and rtyp == types.T.String then
                error("not implemented yet")
            elseif ltyp == types.T.Integer and rtyp == types.T.Float then
                error("not implemented yet") -- see LTnum
            elseif ltyp == types.T.Float and rtyp == types.T.Integer then
                error("not implemented yet") -- see LTnum
            else
                error("impossible")
            end

        elseif op == ">=" then
            if     ltyp == types.T.Integer and rtyp == types.T.Integer then
                return generate_binop(">=", exp, ctx)
            elseif ltyp == types.T.Float and rtyp == types.T.Float then
                return generate_binop(">=", exp, ctx)
            elseif ltyp == types.T.String and rtyp == types.T.String then
                error("not implemented yet")
            elseif ltyp == types.T.Integer and rtyp == types.T.Float then
                error("not implemented yet") -- see LTnum
            elseif ltyp == types.T.Float and rtyp == types.T.Integer then
                error("not implemented yet") -- see LTnum
            else
                error("impossible")
            end

        elseif op == "and" then
            if     ltyp == types.T.Boolean and rtyp == types.T.Boolean then
                local l_cstats, l_cvalue = generate_exp(exp.lhs, ctx)
                local tmp = ctx:new_tvar(types.T.Boolean())
                local r_cstats, r_cvalue = generate_exp(exp.rhs, ctx)

                local cstats = util.render([[
                    ${L_STATS}
                    ${TMP_DECL} = ${L_VALUE};
                    if (${TMP}) {
                      ${R_STATS}
                      ${TMP} = ${R_VALUE};
                    }
                ]], {
                    TMP = tmp.name,
                    TMP_DECL = c_declaration(tmp),
                    L_STATS = l_cstats,
                    L_VALUE = l_cvalue,
                    R_STATS = r_cstats,
                    R_VALUE = r_cvalue,
                })
                return cstats, tmp.name

            else
                error("impossible")
            end

        elseif op == "or" then
            if     ltyp == types.T.Boolean and rtyp == types.T.Boolean then
                local l_cstats, l_cvalue = generate_exp(exp.lhs, ctx)
                local tmp = ctx:new_tvar(types.T.Boolean())
                local r_cstats, r_cvalue = generate_exp(exp.rhs, ctx)

                local cstats = util.render([[
                    ${L_STATS}
                    ${TMP_DECL} = ${L_VALUE};
                    if (!${TMP}) {
                      ${R_STATS}
                      ${TMP} = ${R_VALUE};
                    }
                ]], {
                    TMP = tmp.name,
                    TMP_DECL = c_declaration(tmp),
                    L_STATS = l_cstats,
                    L_VALUE = l_cvalue,
                    R_STATS = r_cstats,
                    R_VALUE = r_cvalue,
                })
                return cstats, tmp.name

            else
                error("impossible")
            end

        else
            error("impossible")
        end

    elseif tag == ast.Exp.Cast then
        local exp_cstats, exp_cvalue = generate_exp(exp.exp, ctx)

        local src_typ = exp.exp._type
        local dst_typ = exp._type

        if     src_typ._tag == dst_typ._tag then
            return exp_cstats, exp_cvalue

        elseif src_typ._tag == types.T.Integer and dst_typ._tag == types.T.Float then
            local v = ctx:new_tvar(dst_typ)
            local cstats = util.render([[
                ${X_STATS}
                ${V_DECL} = (lua_Number) ${X};
            ]], {
                X = exp_cvalue,
                X_STATS = exp_cstats,
                V_DECL = c_declaration(v),
            })
            return cstats, v.name

        elseif src_typ._tag == types.T.Float and dst_typ._tag == types.T.Integer then
            error("not implemented yet")

        else
            error("impossible")
        end

    else
        error("impossible")
    end
end

return coder
